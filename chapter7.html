<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="styles.css">

</head>

<body>

    <header>

    </header>

    <main>
        
        <section>

            <article>

                <h1>7</h1>

                <h1 class="skyblue">Design and implementation</h1>

            </article>    
            
            <article>

                <h2 class="skyblue">Objectives</h2>

                <p>
                    The objectives of this chapter are to introduce object-oriented software design using the UML and highlight important implementation concerns.When you have read this chapter, you will:
                </p>

                <ul>

                    <li>understand the most important activities in a general, objectoriented design process;</li>
                    <li>understand some of the different models that may be used to document an object-oriented design;</li>
                    <li>know about the idea of design patterns and how these are a way of reusing design knowledge and experience;</li>
                    <li>have been introduced to key issues that have to be considered when implementing software, including software reuse and open-source development.</li>

                </ul>

            </article>

            <article>

                <h2 class="skyblue">Contents</h2>

                <ol>

                    <li>Object-oriented design using the UML</li>
                    <li>Design patterns</li>
                    <li>Implementation issues</li>
                    <li>Open source development</li>

                </ol>

            </article>

        </section>



        <section>

            <article>

                <p>Chapter 7 Design and implementation <b>177</b></p>

            </article>

            <article>

                <p>
                Software design and implementation is the stage in the software engineering process
at which an executable software system is developed. For some simple systems, software design and implementation
is software engineering, and all other activities are merged with this process. However, for large systems,
software design and implementation is only one of a set of processes (requirements engineering, verification
and validation, etc.) involved in software engineering.
                </p>

                <p>
                Software design and implementation activities are invariably interleaved.
Software design is a creative activity in which you identify software components and
their relationships, based on a customer’s requirements. Implementation is the
process of realizing the design as a program. Sometimes, there is a separate design
stage and this design is modeled and documented. At other times, a design is in the
programmer’s head or roughly sketched on a whiteboard or sheets of paper. Design
is about how to solve a problem, so there is always a design process. However, it
isn’t always necessary or appropriate to describe the design in detail using the UML
or other design description language.
                </p>

                <p>
Design and implementation are closely linked and you should normally take
implementation issues into account when developing a design. For example, using
the UML to document a design may be the right thing to do if you are programming
in an object-oriented language such as Java or C#. It is less useful, I think, if
you are developing in a dynamically typed language like Python and makes no sense
at all if you are implementing your system by configuring an off-the-shelf package.
As I discussed in Chapter 3, agile methods usually work from informal sketches of
the design and leave many design decisions to programmers.                    
                </p>

                <p>
                One of the most important implementation decisions that has to be made at an
early stage of a software project is whether or not you should buy or build the application
software. In a wide range of domains, it is now possible to buy off-the-shelf
systems (COTS) that can be adapted and tailored to the users’ requirements. For
example, if you want to implement a medical records system, you can buy a package
that is already used in hospitals. It can be cheaper and faster to use this approach
rather than developing a system in a conventional programming language.    
                </p>

                <p>
                When you develop an application in this way, the design process
becomes concerned with how to use the configuration features of that system to
deliver the system requirements. You don’t usually develop design models of the
system, such as models of the system objects and their interactions. I discuss
this COTS-based approach to development in Chapter 16.    
                </p>

                <p>
                I assume that most readers of this book will have had experience of
program design and implementation. This is something that you acquire as you learn
to program and master the elements of a programming language like Java or Python. You
will have probably learned about good programming practice in the programming
languages that you have studied, as well as how to debug programs that you have
developed. Therefore, I don’t cover programming topics here. Instead, this chapter
has two aims:
                </p>

                <ol>

                    <li>
                        To show how system modeling and architectural design (covered in Chapters 5
and 6) are put into practice in developing an object-oriented software design.
                    </li>
                    <li>
                        To introduce important implementation issues that are not usually covered in
programming books. These include software reuse, configuration management,
and open source development.
                    </li>

                </ol>

                <p>
                As there are a vast number of different development platforms,
the chapter is not biased towards any particular programming language or
implementation technology. Therefore, I have presented all examples using the
UML rather than in a programming language such as Java or Python
                </p>

            </article>



            <article>

                <h2 class="skyblue">7.1 Object-oriented design using the UML</h2>

                <p>
                An object-oriented system is made up of interacting objects that maintain their own
local state and provide operations on that state. The representation of the state is private and
cannot be accessed directly from outside the object. Object-oriented design processes involve
designing object classes and the relationships between these classes. These classes define the
objects in the system and their interactions. When the design is realized as an executing program,
the objects are created dynamically from these class definitions.
                </p>

                <p>
                Object-oriented systems are easier to change than systems developed using functional
approaches. Objects include both data and operations to manipulate that data. They may therefore be
understood and modified as stand-alone entities. Changing the implementation of an object or adding
services should not affect other system objects. Because objects are associated with things, there
is often a clear mapping between real-world entities (such as hardware components) and their controlling
objects in the system. This improves the understandability, and hence the maintainability, of the design.
                </p>

                <p>
                To develop a system design from concept to detailed, object-oriented design,
there are several things that you need to do:
                <p>

                <ol>

                    <li>Understand and define the context and the external interactions with the system.</li>
                    <li>Design the system architecture.</li>
                    <li>Identify the principal objects in the system.</li>
                    <li>Develop design models.</li>
                    <li>Specify interfaces.</li>

                </ol>

                <p>
                Like all creative activities, design is not a clear-cut, sequential process. You
develop a design by getting ideas, proposing solutions, and refining these solutions
as information becomes available. You inevitably have to backtrack and retry when
problems arise. Sometimes you explore options in detail to see if they work; at other
times you ignore details until late in the process. Consequently, I have deliberately
not illustrated this process as a simple diagram because that would imply design can
be thought of as a neat sequence of activities. In fact, all of the above activities are
interleaved and so influence each other.
                </p>

                <p>
                I illustrate these process activities by designing part of the software
for the wilderness weather station that I introduced in Chapter 1. Wilderness weather stations are
deployed in remote areas. Each weather station records local weather information and
periodically transfers this to a weather information system, using a satellite link.
                </p>

            </article>



            <article>

                <h2 class="skyblue">7.1.1 System context and interactions</h2>

                <p>
                The first stage in any software design process is to develop an understanding of the
relationships between the software that is being designed and its external environment. This is
essential for deciding how to provide the required system functionality and how to structure the
system to communicate with its environment. Understanding of the context also lets you establish the
boundaries of the system.
                </p>

                <p>
                Setting the system boundaries helps you decide what features are implemented
in the system being designed and what features are in other associated systems. In
this case, you need to decide how functionality is distributed between the control
system for all of the weather stations, and the embedded software in the weather
station itself.
                </p>

                <p>
                System context models and interaction models present complementary views of
the relationships between a system and its environment:
                </p>

                <ol>

                    <li>
                    A system context model is a structural model that demonstrates the
other systems in the environment of the system being developed.

                    </li>
                    <li>
                    An interaction model is a dynamic model that shows how the system interacts
with its environment as it is used.
                    </li>

                </ol>

                <p>
                The context model of a system may be represented using associations. Associations
simply show that there are some relationships between the entities involved in the
association. The nature of the relationships is now specified. You may therefore document the
environment of the system using a simple block diagram, showing the entities
in the system and their associations. This is illustrated in Figure 7.1, which shows that the
systems in the environment of each weather station are a weather information system, an onboard
satellite system, and a control system. The cardinality information on the link shows that there
is one control system but several weather stations, one satellite, and one general weather
information system.
                </p>

                <img src="Images/figure7.1.png" class="centerimage">

                <p>
                When you model the interactions of a system with its environment you should use
an abstract approach that does not include too much detail. One way to do this is to
use a use case model. As I discussed in Chapters 4 and 5, each use case represents an
interaction with the system. Each possible interaction is named in an ellipse and the
external entity involved in the interaction is represented by a stick figure.    
                </p>

                <p>
                The use case model for the weather station is shown in Figure 7.2. This shows
that the weather station interacts with the weather information system to report
weather data and the status of the weather station hardware. Other interactions are
with a control system that can issue specific weather station control commands. As I
explained in Chapter 5, a stick figure is used in the UML to represent other systems
as well as human users.    
                </p>

                <img src="Images/figure7.2.png" class="centerimage">

                <p>
                Each of these use cases should be described in structured natural language. This
helps designers identify objects in the system and gives them an understanding of
what the system is intended to do. I use a standard format for this description that
clearly identifies what information is exchanged, how the interaction is initiated, and so on.
This is shown in Figure 7.3, which describes the Report weather use case from
Figure 7.2. Examples of some other use cases are on the Web.   
                </p>

            </article>



            <article>

            <h2 class="skyblue">7.1.2 Architectural design</h2>

            <p>
            Once the interactions between the software system and the system’s environment
have been defined, you use this information as a basis for designing the system
architecture. Of course, you need to combine this with your general knowledge of
the principles of architectural design and with more detailed domain knowledge.
            </p>

            <p>
            You identify the major components that make up the system and their interactions,
and then may organize the components using an architectural pattern such as a layered or
client–server model. However, this is not essential at this stage.    
            </p>

            <p>
            The high-level architectural design for the weather station software is shown in
Figure 7.4. The weather station is composed of independent subsystems that communicate by
broadcasting messages on a common infrastructure, shown as the
Communication link in Figure 7.4. Each subsystem listens for messages on that
infrastructure and picks up the messages that are intended for them. This is
another commonly used architectural style in addition to those described in
Chapter 6.    
            </p>

            <img src="images/figure7.4.png" class="centerimage">

            <p>
            For example, when the communications subsystem receives a control command, such
as shutdown, the command is picked up by each of the other subsystems, which then shut
themselves down in the correct way. The key benefit of this
architecture is that it is easy to support different configurations of subsystems
because the sender of a message does not need to address the message to a particular subsystem.    
            </p>

            <p>
            Figure 7.5 shows the architecture of the data collection subsystem, which is
included in Figure 7.4. The Transmitter and Receiver objects are concerned with
managing communications and the WeatherData object encapsulates the information
that is collected from the instruments and transmitted to the weather information
system. This arrangement follows the producer-consumer pattern, discussed in
Chapter 20.    
            </p>
            
            <img src="images/figure7.5.png" class="centerimage">
                
            </article>



            <article>
            
            <h2 class="skyblue">7.1.3 Object class identification</h2>

            <p>
            By this stage in the design process, you should have some ideas about
the essential objects in the system that you are designing. As your understanding of the
design develops, you refine these ideas about the system objects. The use case
description helps to identify objects and operations in the system. From the
description of the Report weather use case, it is obvious that objects representing
the instruments that collect weather data will be required, as will an object
representing the summary of the weather data. You also usually need a high-level system
object or objects that encapsulate the system interactions defined in the
use cases. With these objects in mind, you can start to identify the object classes
in the system.   
            </p>
            
            <p>
            There have been various proposals made about how to identify object classes in
object-oriented systems:    
            </p>

            <ol>

                <li>
                Use a grammatical analysis of a natural language description of the system to be
constructed. Objects and attributes are nouns; operations or services are verbs
(Abbott, 1983).
                </li>
                <li>
                Use tangible entities (things) in the application domain such as aircraft, roles
such as manager or doctor, events such as requests, interactions such as meetings, locations such
as offices, organizational units such as companies, and
so on (Coad and Yourdon, 1990; Shlaer and Mellor, 1988; Wirfs-Brock
et al., 1990).
                </li>
                <li>
                Use a scenario-based analysis where various scenarios of system use are identified
and analyzed in turn. As each scenario is analyzed, the team responsible for
the analysis must identify the required objects, attributes, and operations (Beck
and Cunningham, 1989).
                </li>

            </ol>

            <p>
            In practice, you have to use several knowledge sources to discover object classes.
Object classes, attributes, and operations that are initially identified from the informal
system description can be a starting point for the design. Further information
from application domain knowledge or scenario analysis may then be used to refine
and extend the initial objects. This information can be collected from requirements
documents, discussions with users, or from analyses of existing systems.    
            </p>

            <p>
            In the wilderness weather station, object identification is based on the tangible
hardware in the system. I don’t have space to include all the system objects here, but
I have shown five object classes in Figure 7.6. The Ground thermometer,
Anemometer, and Barometer objects are application domain objects, and the
WeatherStation and WeatherData objects have been identified from the system
description and the scenario (use case) description:    
            </p>

            <img src="images/figure7.6.png" class="centerimage">

            <ol>

                <li>
                The WeatherStation object class provides the basic interface of the weather
station with its environment. Its operations reflect the interactions shown in Figure 7.3.
In this case, I use a single object class to encapsulate all of these interactions, but in
other designs you could design the system interface as several different classes.
                </li>
                <li>
                The WeatherData object class is responsible for processing the report weather
command. It sends the summarized data from the weather station instruments to
the weather information system.
                </li>
                <li>
                 The Ground thermometer, Anemometer, and Barometer object classes are
directly related to instruments in the system. They reflect tangible hardware
entities in the system and the operations are concerned with controlling that
hardware. These objects operate autonomously to collect data at the specified
frequency and store the collected data locally. This data is delivered to the
WeatherData object on request.
                </li>

            </ol>

            <p>
            You use knowledge of the application domain to identify other objects, attributes,
and services. We know that weather stations are often located in remote places and
include various instruments that sometimes go wrong. Instrument failures should be
reported automatically. This implies that you need attributes and operations to check
the correct functioning of the instruments. There are many remote weather stations
so each weather station should have its own identifier.
            </p>

            <p>
            At this stage in the design process, you should focus on the objects themselves,
without thinking about how these might be implemented. Once you have identified the
objects, you then refine the object design. You look for common features and then
design the inheritance hierarchy for the system. For example, you may identify an
Instrument superclass, which defines the common features of all instruments, such as an
identifier, and get and test operations. You may also add new attributes and operations to
the superclass, such as an attribute that maintains the frequency of data collection.
            </p>

            </article>



            <article>

            <h2 class="skyblue">7.1.4 Design models</h2>

            <p>
            Design or system models, as I discussed in Chapter 5, show the objects or object classes
in a system. They also show the associations and relationships between these entities.
These models are the bridge between the system requirements and the implementation
of a system. They have to be abstract so that unnecessary detail doesn’t hide the relationships
between them and the system requirements. However, they also have to
include enough detail for programmers to make implementation decisions.
            </p>

            <p>
            Generally, you get around this type of conflict by developing models at different
levels of detail. Where there are close links between requirements engineers, designers, and
programmers, then abstract models may be all that are required. Specific
design decisions may be made as the system is implemented, with problems resolved
through informal discussions. When the links between system specifiers, designers,
and programmers are indirect (e.g., where a system is being designed in one part of
an organization but implemented elsewhere), then more detailed models are likely to
be needed.
            </p>

            <p>
            An important step in the design process, therefore, is to decide on the design
models that you need and the level of detail required in these models. This depends
on the type of system that is being developed. You design a sequential data-processing system
in a different way from an embedded real-time system, so you will need
different design models. The UML supports 13 different types of models but, as I
discussed in Chapter 5, you rarely use all of these. Minimizing the number of models that are
produced reduces the costs of the design and the time required to complete the design process.
            </p>

            <p>
            When you use the UML to develop a design, you will normally develop two kinds
of design model:
            </p>

            <ol>

                <li>
                Structural models, which describe the static structure of the system using object
classes and their relationships. Important relationships that may be documented
at this stage are generalization (inheritance) relationships, uses/used-by relationships, and
composition relationships
                </li>
                <li>
                Dynamic models, which describe the dynamic structure of the system and show
the interactions between the system objects. Interactions that may be documented include the sequence of service requests made by objects and the state
changes that are triggered by these object interactions.
                </li>

            </ol>

            <p>
            In the early stages of the design process, I think there are three models that are
particularly useful for adding detail to use case and architectural models: 
            </p>

            <ol>

                <li>
                Subsystem models, which that show logical groupings of objects into coherent
subsystems. These are represented using a form of class diagram with each subsystem shown as
a package with enclosed objects. Subsystem models are static
(structural) models.
                </li>
                <li>
                 Sequence models, which show the sequence of object interactions. These are
represented using a UML sequence or a collaboration diagram. Sequence
models are dynamic models.
                </li>
                <li>
                State machine model, which show how individual objects change their state in
response to events. These are represented in the UML using state diagrams.
State machine models are dynamic models.
                </li>

            </ol>

            <p>
            A subsystem model is a useful static model as it shows how a design is organized into
logically related groups of objects. I have already shown this type of model in Figure 7.4
to show the subsystems in the weather mapping system. As well as subsystem models,
you may also design detailed object models, showing all of the objects in the systems
and their associations (inheritance, generalization, aggregation, etc.). However, there is
a danger in doing too much modeling. You should not make detailed decisions about the
implementation that really should be left to the system programmers.
            </p>

            <p>
            Sequence models are dynamic models that describe, for each mode of interaction,
the sequence of object interactions that take place. When documenting a design, you
should produce a sequence model for each significant interaction. If you have developed a
use case model then there should be a sequence model for each use case that
you have identified.
            </p>

            <p>
            Figure 7.7 is an example of a sequence model, shown as a UML sequence diagram.
This diagram shows the sequence of interactions that take place when an
external system requests the summarized data from the weather station. You read
sequence diagrams from top to bottom:
            </p>

            <img src="images/figure7.7.png" class="centerimage">

            <ol>

                <li>
                The SatComms object receives a request from the weather information system
to collect a weather report from a weather station. It acknowledges receipt of this request.
The stick arrowhead on the sent message indicates that the external
system does not wait for a reply but can carry on with other processing.
                </li>
                <li>
                SatComms sends a message to WeatherStation, via a satellite link, to create a
summary of the collected weather data. Again, the stick arrowhead indicates
that SatComms does not suspend itself waiting for a reply.
                </li>
                <li>
                WeatherStation sends a message to a Commslink object to summarize the
weather data. In this case, the squared-off style of arrowhead indicates that the
instance of the WeatherStation object class waits for a reply.
                </li>
                <li>
                Commslink calls the summarize method in the object WeatherData and waits for
a reply.
                </li>
                <li>
                The weather data summary is computed and returned to WeatherStation via the
Commslink object.
                </li>
                <li>
                WeatherStation then calls the SatComms object to transmit the summarized
data to the weather information system, through the satellite communications
system.
                </li>

            </ol>

            <p>
            The SatComms and WeatherStation objects may be implemented as concurrent
processes, whose execution can be suspended and resumed. The SatComms object
instance listens for messages from the external system, decodes these messages and
initiates weather station operations.
            </p>

            <p>
            Sequence diagrams are used to model the combined behavior of a group of
objects but you may also want to summarize the behavior of an object or a subsystem
in response to messages and events. To do this, you can use a state machine model
that shows how the object instance changes state depending on the messages that it
receives. The UML includes state diagrams, initially invented by Harel (1987) to
describe state machine models.
            </p>

            <p>
            Figure 7.8 is a state diagram for the weather station system that shows how it
responds to requests for various services.
            </p>

            <p>
            You can read this diagram as follows:
            </p>

            <img src="images/figure7.8.png" class="centerimage">

            <ol>

                <li>
                If the system state is Shutdown then it can respond to a restart(), a reconfigure(),
or a powerSave() message. The unlabeled arrow with the black blob indicates
that the Shutdown state is the initial state. A restart() message causes a transition
to normal operation. Both the powerSave() and reconfigure() messages cause a
transition to a state in which the system reconfigures itself. The state diagram
shows that reconfiguration is only allowed if the system has been shut down.
                </li>
                <li>
                In the Running state, the system expects further messages. If a shutdown()
                message is received, the object returns to the shutdown state.
                </li>
                <li>
                 If a reportWeather() message is received, the system moves to the Summarizing
state. When the summary is complete, the system moves to a Transmitting state
where the information is transmitted to the remote system. It then returns to the
Running state.
                </li>
                <li>
                If a reportStatus() message is received, the system moves to the Testing state,
then the Transmitting state, before returning to the Running state.
                </li>
                <li>
                If a signal from the clock is received, the system moves to the Collecting state,
where it collects data from the instruments. Each instrument is instructed in turn
to collect its data from the associated sensors.
                </li>
                <li>
                 If a remoteControl() message is received, the system moves to a controlled state
in which it responds to a different set of messages from the remote control
room. These are not shown on this diagram.
                </li>

            </ol>

            <p>
            State diagrams are useful high-level models of a system or an object’s operation.
You don’t usually need a state diagram for all of the objects in the system. Many of
the objects in a system are relatively simple and a state model adds unnecessary
detail to the design.
            </p>

            </article>

            <article>

            <h2 class="skyblue">7.1.5 Interface specification</h2>
            
            <p>
            An important part of any design process is the specification of the interfaces between
the components in the design. You need to specify interfaces so that objects and subsystems can be
designed in parallel. Once an interface has been specified, the developers of other objects may
assume that interface will be implemented.
            </p>

            <p>
            Interface design is concerned with specifying the detail of the interface to an
object or to a group of objects. This means defining the signatures and semantics of the services
that are provided by the object or by a group of objects. Interfaces can be
specified in the UML using the same notation as a class diagram. However, there is
no attribute section and the UML stereotype ‹‹interface›› should be included in the
name part. The semantics of the interface may be defined using the object constraint
language (OCL). I explain this in Chapter 17, where I cover component-based software engineering.
I also show an alternative way to represent interfaces in the UML.
            </p>

            <p>
            You should not include details of the data representation in an interface design,
as attributes are not defined in an interface specification. However, you should
include operations to access and update data. As the data representation is hidden, it
can be easily changed without affecting the objects that use that data. This leads to
a design that is inherently more maintainable. For example, an array representation
of a stack may be changed to a list representation without affecting other objects
that use the stack. By contrast, it often makes sense to expose the attributes in a
static design model, as this is the most compact way of illustrating essential characteristics of the objects.
            </p>

            <p>
            There is not a simple 1:1 relationship between objects and interfaces. The same
object may have several interfaces, each of which is a viewpoint on the methods that
it provides. This is supported directly in Java, where interfaces are declared separately from
objects and objects ‘implement’ interfaces. Equally, a group of objects
may all be accessed through a single interface.
            </p>

            <p>
            Figure 7.9 shows two interfaces that may be defined for the weather station. The
left-hand interface is a reporting interface that defines the operation names that are
used to generate weather and status reports. These map directly to operations in the
WeatherStation object. The remote control interface provides four operations, which
map onto a single method in the WeatherStation object. In this case, the individual
operations are encoded in the command string associated with the remoteControl
method, shown in Figure 7.6.
            </p>

            <img src="images/figure7.9.png" class="centerimage">
            
            </article>



            <article>

            <h2 class="skyblue">7.2 Design patterns</h2>

            <p>
            Design patterns were derived from ideas put forward by Christopher Alexander
(Alexander et al., 1977), who suggested that there were certain common patterns of
building design that were inherently pleasing and effective. The pattern is a description
of the problem and the essence of its solution, so that the solution may be reused in different
settings. The pattern is not a detailed specification. Rather, you can think of it
as a description of accumulated wisdom and experience, a well-tried solution to a common problem.

            </p>

            <p>
            A quote from the Hillside Group web site (http://hillside.net), which is dedicated
to maintaining information about patterns, encapsulates their role in reuse:
            </p>

            <p>
            <i>
            Patterns and Pattern Languages are ways to describe best practices, good
designs, and capture experience in a way that it is possible for others to reuse
this experience.
            </i>
            </p>

            <p>
            Patterns have made a huge impact on object-oriented software design. As well as
being tested solutions to common problems, they have become a vocabulary for talking about a
design. You can therefore explain your design by describing the patterns
that you have used. This is particularly true for the best-known design patterns that
were originally described by the ‘Gang of Four’ in their patterns book, (Gamma et al.,
1995). Other particularly important pattern descriptions are those published in a series
of books by authors from Siemens, a large European technology company
(Buschmann et al., 1996; Buschmann et al., 2007a; Buschmann et al., 2007b; Kircher
and Jain, 2004; Schmidt et al., 2000).
            </p>

            <p>
            Design patterns are usually associated with object-oriented design. Published
patterns often rely on object characteristics such as inheritance and polymorphism to
provide generality. However, the general principle of encapsulating experience in a pattern
is one that is equally applicable to any kind of software design. So, you could
have configuration patterns for COTS systems. Patterns are a way of reusing the
knowledge and experience of other designers.
            </p>

            <p>
            The four essential elements of design patterns were defined by the ‘Gang of Four’
in their patterns book:
            </p>

            <ol>
                
                <li>
                A name that is a meaningful reference to the pattern.
                </li>
                <li>
                 A description of the problem area that explains when the pattern may be
applied.
                </li>
                <li>
                 A solution description of the parts of the design solution, their relationships, and
their responsibilities. This is not a concrete design description. It is a template
for a design solution that can be instantiated in different ways. This is often
expressed graphically and shows the relationships between the objects and
object classes in the solution.
                </li>
                <li>
                A statement of the consequences—the results and trade-offs—of applying the
pattern. This can help designers understand whether or not a pattern can be used
in a particular situation.
                </li>

            </ol>

            <p>
            Gamma and his co-authors break down the problem description into motivation
(a description of why the pattern is useful) and applicability (a description of situations
in which the pattern may be used). Under the description of the solution, they describe
the pattern structure, participants, collaborations, and implementation.
            </p>

            <p>
            To illustrate pattern description, I use the Observer pattern, taken from the book
by Gamma et al. (Gamma et al., 1995). This is shown in Figure 7.10. In my description, I use the
four essential description elements and also include a brief statement
of what the pattern can do. This pattern can be used in situations where different
presentations of an object’s state are required. It separates the object that must be
displayed from the different forms of presentation. This is illustrated in Figure 7.11,
which shows two graphical presentations of the same data set.
            </p>

            <img src="images/figure7.11.png" class="centerimage">

            <p>
            Graphical representations are normally used to illustrate the object classes in
patterns and their relationships. These supplement the pattern description and add detail to
the solution description. Figure 7.12 is the representation in UML of the
Observer pattern.
            </p>

            <img src="images/figure7.12.png" class="centerimage">

            <p>
            To use patterns in your design, you need to recognize that any design problem
you are facing may have an associated pattern that can be applied. Examples of such
problems, documented in the ‘Gang of Four’s original patterns book, include:
            </p>

            <ol>
                
                <li>
                Tell several objects that the state of some other object has changed (Observer
pattern).
                </li>
                <li>
                Tidy up the interfaces to a number of related objects that have
often been developed incrementally (Façade pattern).
                </li>
                <li>
                Provide a standard way of accessing the elements in a collection, irrespective of
how that collection is implemented (Iterator pattern).
                </li>
                <li>
                Allow for the possibility of extending the functionality of an existing class at
run-time (Decorator pattern).
                </li>

            </ol>

            <p>
            Patterns support high-level, concept reuse. When you try to reuse executable
components you are inevitably constrained by detailed design decisions that have
been made by the implementers of these components. These range from the
particular algorithms that have been used to implement the components to the
objects and types in the component interfaces. When these design decisions conflict with
your particular requirements, reusing the component is either
impossible or introduces inefficiencies into your system. Using patterns means
that you reuse the ideas but can adapt the implementation to suit the system that
you are developing.
            </p>

            <p>
            When you start designing a system, it can be difficult to know, in advance, if you
will need a particular pattern. Therefore, using patterns in a design process often
involves developing a design, experiencing a problem, and then recognizing that a
pattern can be used. This is certainly possible if you focus on the 23 general-purpose patterns
documented in the original patterns book. However, if your problem is a different one, you may
find it difficult to find an appropriate pattern amongst the hundreds of different patterns that
have been proposed.
            </p>

            <p>
            Patterns are a great idea but you need experience of software design to use them
effectively. You have to recognize situations where a pattern can be applied.
Inexperienced programmers, even if they have read the pattern books, will always
find it hard to decide whether they can reuse a pattern or need to develop a specialpurpose solution.
            </p>

            </article>



            <article>
                
            <h2 class="skyblue">7.3 Implementation issues</h2>
            
            <p>
            Software engineering includes all of the activities involved in software development
from the initial requirements of the system through to maintenance and management of the deployed
system. A critical stage of this process is, of course, system
implementation, where you create an executable version of the software.
Implementation may involve developing programs in high- or low-level programming
languages or tailoring and adapting generic, off-the-shelf systems to meet the specific
requirements of an organization.
            </p>

            <p>
            I assume that most readers of this book will understand programming principles
and will have some programming experience. As this chapter is intended to offer a
language-independent approach, I haven’t focused on issues of good programming
practice as this has to use language-specific examples. Instead, I introduce some
aspects of implementation that are particularly important to software engineering
that are often not covered in programming texts. These are:
            </p>

            <ol>

                <li>
                Reuse Most modern software is constructed by reusing existing components or
systems. When you are developing software, you should make as much use as
possible of existing code.
                </li>

                <li>
                Configuration management During the development process, many different
versions of each software component are created. If you don’t keep track of
these versions in a configuration management system, you are liable to include
the wrong versions of these components in your system.
                </li>

                <li>
                Host-target development Production software does not usually execute on the
same computer as the software development environment. Rather, you develop
it on one computer (the host system) and execute it on a separate computer (the
target system). The host and target systems are sometimes of the same type but,
often they are completely different.
                </li>

            </ol>

            </article>



            <article>

            <h2 class="skyblue">7.3.1 Reuse</h2>

            <p>
            From the 1960s to the 1990s, most new software was developed from scratch, by
writing all code in a high-level programming language. The only significant reuse or software
was the reuse of functions and objects in programming language libraries.
However, costs and schedule pressure meant that this approach became increasingly
unviable, especially for commercial and Internet-based systems. Consequently, an
approach to development based around the reuse of existing software emerged and is
now generally used for business systems, scientific software, and, increasingly, in
embedded systems engineering.
            </p>

            <p>
            Software reuse is possible at a number of different levels:
            </p>

            <ol>

                <li>
                The abstraction level At this level, you don’t reuse software directly but rather
use knowledge of successful abstractions in the design of your software. Design
patterns and architectural patterns (covered in Chapter 6) are ways of representing abstract
knowledge for reuse.
                </li>

                <li>
                The object level At this level, you directly reuse objects from a library rather
than writing the code yourself. To implement this type of reuse, you have to find
appropriate libraries and discover if the objects and methods offer the functionality that you need.
For example, if you need to process mail messages in a Java
program, you may use objects and methods from a JavaMail library.
                </li>

                <li>
                The component level Components are collections of objects and object classes
that operate together to provide related functions and services. You often have to
adapt and extend the component by adding some code of your own. An example
of component-level reuse is where you build your user interface using a framework. This is a
set of general object classes that implement event handling, display management, etc. You add
connections to the data to be displayed and
write code to define specific display details such as screen layout and colors.
                </li>

                <li>
                The system level At this level, you reuse entire application systems. This usually
involves some kind of configuration of these systems. This may be done by
adding and modifying code (if you are reusing a software product line) or by
using the system’s own configuration interface. Most commercial systems are
now built in this way where generic COTS (commercial off-the-shelf) systems
are adapted and reused. Sometimes this approach may involve reusing several
different systems and integrating these to create a new system.
                </li>

            </ol>

            <p>
            By reusing existing software, you can develop new systems more quickly, with
fewer development risks and also lower costs. As the reused software has been tested
in other applications, it should be more reliable than new software. However, there
are costs associated with reuse:
            </p>

            <ol>

                <li>
                The costs of the time spent in looking for software to reuse and assessing
whether or not it meets your needs. You may have to test the software to make
sure that it will work in your environment, especially if this is different from its
development environment.
                </li>

                <li>
                Where applicable, the costs of buying the reusable software. For large off-the-shelf
systems, these costs can be very high.
                </li>

                <li>
                The costs of adapting and configuring the reusable software components or systems
to reflect the requirements of the system that you are developing.
                </li>

                <li>
                The costs of integrating reusable software elements with each other (if you are
using software from different sources) and with the new code that you have
developed. Integrating reusable software from different providers can be difficult and expensive because the providers may make conflicting assumptions
about how their respective software will be reused.
                </li>

            </ol>

            <p>
            How to reuse existing knowledge and software should be the first thing you should
think about when starting a software development project. You should consider the
possibilities of reuse before designing the software in detail, as you may wish to adapt
your design to reuse existing software assets. As I discussed in Chapter 2, in a reuseoriented development process, you search for reusable elements then modify your
requirements and design to make best use of these.
            </p>

            <p>
            For a large number of application systems, software engineering really means
software reuse. I therefore devote several chapters in the software technologies section
of the book to this topic (Chapters 16, 17, and 19).
            </p>

            </article>



            <article>

            <h2 class="skyblue">7.3.2 Configuration management</h2>

            <p>
            In software development, change happens all the time, so change management is
absolutely essential. When a team of people are developing software, you have to
make sure that team members don’t interfere with each others’ work. That is, if two
people are working on a component, their changes have to be coordinated. Otherwise,
one programmer may make changes and overwrite the other’s work. You also have to
ensure that everyone can access the most up-to-date versions of software components,
otherwise developers may redo work that has already been done. When something
goes wrong with a new version of a system, you have to be able to go back to a working
version of the system or component.
            </p>

            <p>
            Configuration management is the name given to the general process of managing
a changing software system. The aim of configuration management is to support the
system integration process so that all developers can access the project code and documents
in a controlled way, find out what changes have been made, and compile and
link components to create a system. There are, therefore, three fundamental configuration
management activities:
            </p>

            <ol>

                <li>
                Version management, where support is provided to keep track of the different
versions of software components. Version management systems include facilities to coordinate
development by several programmers. They stop one developer overwriting code that has been
submitted to the system by someone else.
                </li>

                <li>
                System integration, where support is provided to help developers define what
versions of components are used to create each version of a system. This
description is then used to build a system automatically by compiling and linking the required components.
                </li>

                <li>
                Problem tracking, where support is provided to allow users to report bugs and
other problems, and to allow all developers to see who is working on these problems and when they are fixed.
                </li>

            </ol>

            <p>
            Software configuration management tools support each of the above activities.
These tools may be designed to work together in a comprehensive change management
system, such as ClearCase (Bellagio and Milligan, 2005). In integrated configuration
management systems, version management, system integration, and problem-tracking
tools are designed together. They share a user interface style and are integrated through
a common code repository.
            </p>

            <p>
            Alternatively, separate tools, installed in an integrated development environment,
may be used. Version management may be supported using a version management
system such as Subversion (Pilato et al., 2008), which can support multi-site, multiteam development.
System integration support may be built into the language or rely
on a separate toolset such as the GNU build system. This includes what is perhaps
the best-known integration tool, Unix make. Bug tracking or issue tracking systems,
such as Bugzilla, are used to report bugs and other issues and to keep track of
whether or not these have been fixed.
            </p>

            <p>
            Because of its importance in professional software engineering, I discuss change
and configuration management in more detail in Chapter 25.
            </p>

            </article>



            <article>
                
            <h2 class="skyblue">7.3.3 Host-target development</h2>

            <p>
            Most software development is based on a host-target model. Software is developed on
one computer (the host), but runs on a separate machine (the target). More generally,
we can talk about a development platform and an execution platform. A platform is
more than just hardware. It includes the installed operating system plus other supporting software
such as a database management system or, for development platforms,
an interactive development environment.
            </p>

            <p>
            Sometimes, the development and execution platforms are the same, making it possible
to develop the software and test it on the same machine. More commonly, however,
they are different so that you need to either move your developed software to the execution
platform for testing or run a simulator on your development machine.
            </p>

            <p>
            Simulators are often used when developing embedded systems. You simulate hardware devices,
such as sensors, and the events in the environment in which the system
will be deployed. Simulators speed up the development process for embedded systems
as each developer can have their own execution platform with no need to download the
software to the target hardware. However, simulators are expensive to develop and so
are only usually available for the most popular hardware architectures.
            </p>

            <p>
            If the target system has installed middleware or other software that you need to
use, then you need to be able to test the system using that software. It may be impractical
to install that software on your development machine, even if it is the same as
the target platform, because of license restrictions. In those circumstances, you need
to transfer your developed code to the execution platform to test the system.
            </p>

            <p>
            A software development platform should provide a range of tools to support software
engineering processes. These may include:
            </p>

            <ol>
                
                <li>
                An integrated compiler and syntax-directed editing system that allows you to
create, edit, and compile code.
                </li>

                <li>
                A language debugging system.
                </li>

                <li>
                Graphical editing tools, such as tools to edit UML models.
                </li>

                <li>
                Testing tools, such as JUnit (Massol, 2003) that can automatically run a set of
tests on a new version of a program.
                </li>

                <li>
                Project support tools that help you organize the code for different development
projects.
                </li>

            </ol>

            <p>
            As well as these standard tools, your development system may include more specialized
tools such as static analyzers (discussed in Chapter 15). Normally, development
environments for teams also include a shared server that runs a change and configuration
management system and, perhaps, a system to support requirements
management.
            </p>

            <p>
            Software development tools are often grouped to create an integrated development
environment (IDE). An IDE is a set of software tools that supports different
aspects of software development, within some common framework and user interface. Generally,
IDEs are created to support development in a specific programming
language such as Java. The language IDE may be developed specially, or may be an
instantiation of a general-purpose IDE, with specific language-support tools.
            </p>

            <p>
            A general-purpose IDE is a framework for hosting software tools that provides data
management facilities for the software being developed, and integration mechanisms,
that allow tools to work together. The best-known general-purpose IDE is the Eclipse
environment (Carlson, 2005). This environment is based on a plug-in architecture so
that it can be specialized for different languages and application domains (Clayberg and
Rubel, 2006). Therefore, you can install Eclipse and tailor it for your specific needs by
adding plug-ins. For example, you may add a set of plug-ins to support networked systems development
in Java or embedded systems engineering using C.
            </p>

            <p>
            As part of the development process, you need to make decisions about how the
developed software will be deployed on the target platform. This is straightforward
for embedded systems, where the target is usually a single computer. However, for
distributed systems, you need to decide on the specific platforms where the
components will be deployed. Issues that you have to consider in making this decision are: 
            </p>

            <ol>
                
                <li>
                The hardware and software requirements of a component If a component is
designed for a specific hardware architecture, or relies on some other software
system, it must obviously be deployed on a platform that provides the required
hardware and software support.
                </li>

                <li>
                The availability requirements of the system High-availability systems may
require components to be deployed on more than one platform. This means that,
in the event of platform failure, an alternative implementation of the component
is available.
                </li>

                <li>
                Component communications If there is a high level of communications traffic
between components, it usually makes sense to deploy them on the same platform or on platforms
that are physically close to one other. This reduces
communications latency, the delay between the time a message is sent by one
component and received by another.
                </li>

            </ol>

            <p>
            You can document your decisions on hardware and software deployment using UML
deployment diagrams, which show how software components are distributed across
hardware platforms.
            </p>

            <p>
            If you are developing an embedded system, you may have to take into account
target characteristics, such as its physical size, power capabilities, the need for realtime
responses to sensor events, the physical characteristics of actuators, and its realtime
operating system. I discuss embedded systems engineering in Chapter 20.
            </p>

            </article>



            <article>

            <h2 class="skyblue">7.4 Open source development</h2>

            <p>
            Open source development is an approach to software development in which the
source code of a software system is published and volunteers are invited to participate
in the development process (Raymond, 2001). Its roots are in the Free Software
Foundation (http://www.fsf.org), which advocates that source code should not be
proprietary but rather should always be available for users to examine and modify as
they wish. There was an assumption that the code would be controlled and developed by a
small core group, rather than users of the code.
            </p>

            <p>
            Open source software extended this idea by using the Internet to recruit a much
larger population of volunteer developers. Many of them are also users of the code.
In principle at least, any contributor to an open source project may report and fix
bugs and propose new features and functionality. However, in practice, successful
open source systems still rely on a core group of developers who control changes to
the software.
            </p>

            <p>
            The best-known open source product is, of course, the Linux operating system
which is widely used as a server system and, increasingly, as a desktop environment.
Other important open source products are Java, the Apache web server, and the
mySQL database management system. Major players in the computer industry such
as IBM and Sun support the open source movement and base their software on open
source products. There are thousands of other, lesser known open source systems
and components that may also be used.
            </p>

            <p>
            It is usually fairly cheap or free to acquire open source software. You
can normally download open source software without charge. However, if you want
documentation and support, then you may have to pay for this, but costs are usually fairly
low. The other key benefit of using open source products is that mature open source
systems are usually very reliable. The reason for this is that they have a large population
of users who are willing to fix problems themselves rather than report these
problems to the developer and wait for a new release of the system. Bugs are discovered
and repaired more quickly than is usually possible with proprietary software.
            </p>

            <p>
            For a company involved in software development, there are two open source
issues that have to be considered:
            </p>

            <ol>

                <li>
                Should the product that is being developed make use of open source components?
                </li>

                <li>
                Should an open source approach be used for the software’s development?
                </li>

            </ol>

            <p>
            The answers to these questions depend on the type of software that is being
developed and the background and experience of the development team.
            </p>

            <p>
            If you are developing a software product for sale, then time to market and reduced
costs are critical. If you are developing in a domain in which there are high-quality
open source systems available, you can save time and money by using these systems.
However, if you are developing software to a specific set of organizational requirements, then
using open source components may not be an option. You may have to
integrate your software with existing systems that are incompatible with available
open source systems. Even then, however, it could be quicker and cheaper to modify
the open source system rather than redevelop the functionality that you need.
            </p>

            <p>
            More and more product companies are using an open source approach to development.
Their business model is not reliant on selling a software product but rather on
selling support for that product. They believe that involving the open source community will
allow software to be developed more cheaply, more quickly, and will create
a community of users for the software. Again, however, this is really only applicable
for general software products rather than specific organizational applications.
            </p>

            <p>
            Many companies believe that adopting an open source approach will reveal confidential
business knowledge to their competitors and so are reluctant to adopt this
development model. However, if you are working in a small company and you open
source your software, this may reassure customers that they will be able to support
the software if your company goes out of business.
            </p>

            <p>
            Publishing the source code of a system does not mean that people from the wider
community will necessarily help with its development. Most successful open source products
have been platform products rather than application systems. There are a
limited number of developers who might be interested in specialized application systems.
As such, making a software system open source does not guarantee community involvement.
            </p>

            </article>



            <article>

            <h2 class="skyblue">7.4.1 Open source licensing</h2>

            <p>
            Although a fundamental principle of open-source development is that source code
should be freely available, this does not mean that anyone can do as they wish with
that code. Legally, the developer of the code (either a company or an individual) still
owns the code. They can place restrictions on how it is used by including legally
binding conditions in an open source software license (St. Laurent, 2004). Some
open source developers believe that if an open source component is used to develop
a new system, then that system should also be open source. Others are willing to
allow their code to be used without this restriction. The developed systems may be
proprietary and sold as closed source systems.
            </p>

            <p>
            Most open source licenses are derived from one of three general models:
            </p>

            <ol>
                
                <li>
                 The GNU General Public License (GPL). This is a so-called ‘reciprocal’ license
that, simplistically, means that if you use open source software that is licensed
under the GPL license, then you must make that software open source.
                </li>

                <li>
                The GNU Lesser General Public License (LGPL). This is a variant of the GPL
license where you can write components that link to open source code without
having to publish the source of these components. However, if you change the
licensed component, then you must publish this as open source.
                </li>

                <li>
                The Berkley Standard Distribution (BSD) License. This is a non-reciprocal
license, which means you are not obliged to republish any changes or modifications made to
open source code. You can include the code in proprietary systems
that are sold. If you use open source components, you must acknowledge the
original creator of the code.
                </li>

            </ol>

            <p>
            Licensing issues are important because if you use open-source software as part of
a software product, then you may be obliged by the terms of the license to make your
own product open source. If you are trying to sell your software, you may wish to
keep it secret. This means that you may wish to avoid using GPL-licensed open
source software in its development.
            </p>

            <p>
            If you are building software that runs on an open source platform, such as Linux,
then licenses are not a problem. However, as soon as you start including open source
components in your software you need to set up processes and databases to keep
track of what’s been used and their license conditions. Bayersdorfer (2007) suggests
that companies managing projects that use open source should:
            </p>

            <ol>
                
                <li>
                Establish a system for maintaining information about open source components
that are downloaded and used. You have to keep a copy of the license for each component that
was valid at the time the component was used. Licenses may
change so you need to know the conditions that you have agreed to.

                </li>
                
                <li>
                Be aware of the different types of licenses and understand how a component is
licensed before it is used. You may decide to use a component in one system but
not in another because you plan to use these systems in different ways.
                </li>

                <li>
                Be aware of evolution pathways for components. You need to know a bit about
the open source project where components are developed to understand how
they might change in future
                </li>

                <li>
                Educate people about open source. It’s not enough to have procedures in place
to ensure compliance with license conditions. You also need to educate developers about open
source and open source licensing.
                </li>

                <li>
                Have auditing systems in place. Developers, under tight deadlines, might be
tempted to break the terms of a license. If possible, you should have software in
place to detect and stop this.
                </li>

                <li>
                Participate in the open source community. If you rely on open source products,
you should participate in the community and help support their development.
                </li>

            </ol>

            <p>
            The business model of software is changing. It is becoming increasingly difficult
to build a business by selling specialized software systems. Many companies prefer
to make their software open source and then sell support and consultancy to software
users. This trend is likely to accelerate, with increasing use of open source software
and with more and more software available in this form.
            </p>
            
            </article>

        </section>

    </main>

    <footer>

    </footer>

</body>

</html>
